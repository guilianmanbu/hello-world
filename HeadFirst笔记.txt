设计原则：
  开闭
  单一职责
  里氏代换
  接口隔离
  最少知识
  合成复合
  依赖倒置


解耦原理：通过在调用者和被调用者之间增加抽象中间层，而使得一方的变化不会影响另一方。通过层层委托，
将最终的实际处理放在合适的位置（底层），也就是上层不依赖具体，而是依赖中间的抽象接口，
同样底层的实现也需要遵守接口的规则，也就是底层也针对接口编程。


装饰模式：保留接口；增添功能
适配模式：转换接口
外观模式：简化接口
代理模式：保持接口

适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口。

多态来封装变化，两个针对角度：行为，属性；  两个粒度：对象/类，方法

工厂方法：由子类决定实例化哪个具体类。 以继承方式在方法粒度上获取不同的对象。
策略：封装可互换的行为，然后使用委托来决定要采用哪个行为。  针对行为，合成聚合方式
模板方法：子类决定如何实现算法中的步骤。  继承方式，方法粒度，针对行为

真实应用中，很多是模式的变体，并不一定严格是书上所讲，应学会识别。
模板模式有多种方式，常用来定义框架。

继承中基类提供了共有的方法，可以做统一调用，但不使用继承方式却又想有统一的方法可以调用时就可以使用接口。其实接口也是一种继承，不同的是
基类继承方式是实例级别，不光继承了行为也继承了属性；而接口继承的粒度更小，目标直指具体的方法行为。 继承的最终目的也就是代码重用与方法共享。

Unity的脚本生命周期就可以理解为一种模板。
模板模式的整体算法框架是死的，在编译期固化的，运行中能变的是其中某些步骤的实现细节。
策略模式是整个算法的替换，在运行时动态替换整个算法。
它们都是侧重算法的变化与替换，模板是局部而策略就是全部。

组合模式形成树形结构，通过让枝节点和叶节点实现同一接口而使得对整棵树的操作一致。  例如：component组件

策略――封装可互换的行为，并使用委托决定使用哪一个
适配器――改变一个或多个类的接口
迭代器――提供一个方式来遍历集合，而无须暴露集合的实现
外观――简化一群类的接口
组合――客户可以将对象的集合以及个别的对象一视同仁
观察者――当某个状态改变时，允许一群对象能被通知到
模板方法――由子类决定如何实现算法中的某些步骤
状态――封装基于状态的行为，并将行为委托到当前状态

装饰者――包装另一个对象，并提供额外的行为
外观――包装许多对象以简化它们的接口
代理――包装另一个对象，并控制对它的访问
适配器――包装另一个对象，并提供不同的接口

